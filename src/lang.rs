use crate::{bump::BumpError, version::Version};
use std::fs;
use std::path::Path;
use toml_edit::DocumentMut;

#[derive(Debug, Clone, Copy)]
pub enum Language {
    C,
    Go,
    Java,
    CSharp,
    Rust,
}

impl Language {
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "c" => Some(Language::C),
            "go" => Some(Language::Go),
            "java" => Some(Language::Java),
            "csharp" => Some(Language::CSharp),
            "rust" => Some(Language::Rust),
            _ => None,
        }
    }

    fn file_description(self) -> &'static str {
        match self {
            Language::C => "C header file",
            Language::Go => "Go source file",
            Language::Java => "Java source file",
            Language::CSharp => "C# source file",
            Language::Rust => "Cargo.toml",
        }
    }
}

fn c_output(version: &Version, path: &Path, version_str: &str) -> Result<(), BumpError> {
    let content = format!(
        r#"/** This file is generated by:
 *  ____  __  __  __  __  ____ 
 * (  _ \(  )(  )(  \/  )(  _ \
 *  ) _ < )(__)(  )    (  )___/
 * (____/(______)(_/\/\_)(__)  
 *
 * https://github.com/launchfirestorm/bump
 */

#ifndef BUMP_VERSION_H
#define BUMP_VERSION_H

#define VERSION_PREFIX "{}"
#define VERSION_MAJOR {}
#define VERSION_MINOR {}
#define VERSION_PATCH {}
#define VERSION_CANDIDATE {}
#define VERSION_STRING "{}"
{}

#endif /* BUMP_VERSION_H */
"#,
        version.prefix,
        version.major,
        version.minor,
        version.patch,
        version.candidate,
        version_str,
        version
            .timestamp
            .as_ref()
            .map_or(String::new(), |ts| format!(
                "#define VERSION_TIMESTAMP \"{}\"\n",
                ts
            ))
    );

    fs::write(path, content).map_err(BumpError::IoError)?;
    println!(
        "{} written to {}",
        Language::C.file_description(),
        path.display()
    );
    Ok(())
}

fn go_output(version: &Version, path: &Path, version_str: &str) -> Result<(), BumpError> {
    let content = format!(
        r#"// This file is generated by:
//  ____  __  __  __  __  ____ 
// (  _ \(  )(  )(  \/  )(  _ \
//  ) _ < )(__)(  )    (  )___/
// (____/(______)(_/\/\_)(__)  
//
// https://github.com/launchfirestorm/bump

package version

const (
	PREFIX    = "{}"
	MAJOR     = {}
	MINOR     = {}
	PATCH     = {}
	CANDIDATE = {}
	STRING    = "{}"
    TIMESTAMP = "{}"
)
"#,
        version.prefix,
        version.major,
        version.minor,
        version.patch,
        version.candidate,
        version_str,
        version.timestamp.as_deref().unwrap_or(&String::new())
    );

    fs::write(path, content).map_err(BumpError::IoError)?;
    println!(
        "{} written to {}",
        Language::Go.file_description(),
        path.display()
    );
    Ok(())
}

fn java_output(version: &Version, path: &Path, version_str: &str) -> Result<(), BumpError> {
    let content = format!(
        r#"/**
 * This file is generated by:
 *  ____  __  __  __  __  ____ 
 * (  _ \(  )(  )(  \/  )(  _ \
 *  ) _ < )(__)(  )    (  )___/
 * (____/(______)(_/\/\_)(__)  
 *
 * https://github.com/launchfirestorm/bump
 */

public class Version {{
    public static final String PREFIX = "{}";
    public static final int MAJOR = {};
    public static final int MINOR = {};
    public static final int PATCH = {};
    public static final int CANDIDATE = {};
    public static final String STRING = "{}";
    public static final String TIMESTAMP = "{}";
}}
"#,
        version.prefix,
        version.major,
        version.minor,
        version.patch,
        version.candidate,
        version_str,
        version.timestamp.as_deref().unwrap_or(&String::new())
    );

    fs::write(path, content).map_err(BumpError::IoError)?;
    println!(
        "{} written to {}",
        Language::Java.file_description(),
        path.display()
    );
    Ok(())
}

fn csharp_output(version: &Version, path: &Path, version_str: &str) -> Result<(), BumpError> {
    let content = format!(
        r#"/**
 * This file is generated by:
 *  ____  __  __  __  __  ____ 
 * (  _ \(  )(  )(  \/  )(  _ \
 *  ) _ < )(__)(  )    (  )___/
 * (____/(______)(_/\/\_)(__)  
 *
 * https://github.com/launchfirestorm/bump
 */

public static class Version {{
    public const string PREFIX = "{}";
    public const int MAJOR = {};
    public const int MINOR = {};
    public const int PATCH = {};
    public const int CANDIDATE = {};
    public const string STRING = "{}";
    public const string TIMESTAMP = "{}";
}}
"#,
        version.prefix,
        version.major,
        version.minor,
        version.patch,
        version.candidate,
        version_str,
        version.timestamp.as_deref().unwrap_or(&String::new())
    );

    fs::write(path, content).map_err(BumpError::IoError)?;
    println!(
        "{} written to {}",
        Language::CSharp.file_description(),
        path.display()
    );
    Ok(())
}

fn rust_output(_version: &Version, path: &Path, version_str: &str) -> Result<(), BumpError> {
    // Read existing Cargo.toml
    let content = fs::read_to_string(path).map_err(BumpError::IoError)?;

    // Parse with toml_edit to preserve formatting
    let mut doc = content
        .parse::<DocumentMut>()
        .map_err(|e| BumpError::ParseError(format!("failed to parse {}: {}", path.display(), e)))?;

    // Update version in [package] section
    // Strip the prefix (e.g., "v") from the version string for Cargo.toml
    let cargo_version = version_str
        .strip_prefix('v')
        .unwrap_or(version_str);

    if let Some(package) = doc.get_mut("package") {
        package["version"] = toml_edit::value(cargo_version);
    } else {
        return Err(BumpError::ParseError(
            format!("no [package] section found in {}", path.display()),
        ));
    }

    fs::write(path, doc.to_string()).map_err(BumpError::IoError)?;
    println!(
        "{} updated to version {}",
        Language::Rust.file_description(),
        cargo_version
    );
    Ok(())
}

pub fn output_file(
    lang: &Language,
    version: &Version,
    version_str: &str,
    path: &Path,
) -> Result<(), BumpError> {
    match lang {
        Language::C => c_output(version, path, version_str),
        Language::Go => go_output(version, path, version_str),
        Language::Java => java_output(version, path, version_str),
        Language::CSharp => csharp_output(version, path, version_str),
        Language::Rust => rust_output(version, path, version_str),
    }
}
