use clap::{Arg, ArgMatches, Command};
use std::{
    fmt, fs, io,
    path::{Path, PathBuf},
};

#[cfg(test)]
mod tests;

#[derive(Debug)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
    path: PathBuf,
}

#[derive(Debug)]
enum VersionError {
    IoError(io::Error),
    ParseError(String),
}

impl fmt::Display for VersionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VersionError::IoError(err) => write!(f, "I/O error: {}", err),
            VersionError::ParseError(field) => write!(f, "Invalid {} value", field),
        }
    }
}

impl From<io::Error> for VersionError {
    fn from(err: io::Error) -> Self {
        VersionError::IoError(err)
    }
}

impl Version {
    fn default(path: &Path) -> Self {
        Version {
            major: 0,
            minor: 1,
            patch: 0,
            path: path.to_path_buf(),
        }
    }

    fn from_file(path: &Path) -> Result<Self, VersionError> {
        let content = fs::read_to_string(path)?;

        let mut major = 0;
        let mut minor = 0;
        let mut patch = 0;

        for line in content.lines() {
            if let Some(value) = line.strip_prefix("MAJOR=") {
                major = value
                    .trim()
                    .parse()
                    .map_err(|_| VersionError::ParseError("MAJOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("MINOR=") {
                minor = value
                    .trim()
                    .parse()
                    .map_err(|_| VersionError::ParseError("MINOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("PATCH=") {
                patch = value
                    .trim()
                    .parse()
                    .map_err(|_| VersionError::ParseError("PATCH".to_string()))?;
            }
        }
        Ok(Version {
            major,
            minor,
            patch,
            path: path.to_path_buf(),
        })
    }

    fn to_file(&self) -> Result<(), io::Error> {
        let content = format!(
            r#"# This file is generated by:
#  ____  __  __  __  __  ____ 
# (  _ \(  )(  )(  \/  )(  _ \
#  ) _ < )(__)(  )    (  )___/
# (____/(______)(_/\/\_)(__)  
#
# https://github.com/launchfirestorm/bump

MAJOR={}
MINOR={}
PATCH={}
"#,
            self.major, self.minor, self.patch
        );
        fs::write(self.path.as_path(), content)
    }

    fn bump(&mut self, major: bool, minor: bool, patch: bool) -> bool {
        if !major && !minor && !patch {
            eprintln!("Nothing to bump! Must provide one of --major, --minor, or --patch");
            return false;
        }
        if major {
            self.major += 1;
            self.minor = 0;
            self.patch = 0;
        } else if minor {
            self.minor += 1;
            self.patch = 0;
        } else if patch {
            self.patch += 1;
        }
        true
    }

    fn to_header(&self) -> String {
        format!(
            r#"/** This file is generated by:
*  ____  __  __  __  __  ____ 
* (  _ \(  )(  )(  \/  )(  _ \
*  ) _ < )(__)(  )    (  )___/
* (____/(______)(_/\/\_)(__)  
*
* https://github.com/launchfirestorm/bump
*/

#define VERSION_MAJOR {}
#define VERSION_MINOR {}
#define VERSION_PATCH {}
"#,
            self.major, self.minor, self.patch
        )
    }
}

pub fn resolve_path(input_path: &str) -> Result<PathBuf, io::Error> {
    let path = Path::new(input_path);
    
    let resolved_path = if path.is_absolute() {
        // Absolute path - return as is
        path.to_path_buf()
    } else {
        // Relative path - resolve relative to current directory
        std::env::current_dir()
            .unwrap_or_else(|_| PathBuf::from("."))
            .join(path)
    };

    Ok(resolved_path)
}

pub fn ensure_directory_exists(path: &Path) -> Result<(), io::Error> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }
    Ok(())
}

fn prompt_for_version(path: &Path) -> Result<Version, Box<dyn std::error::Error>> {
    let mut version_input = String::new();
    println!("Enter the version number (e.g. 1.2.3) or press enter for default (0.1.0): ");

    io::stdin().read_line(&mut version_input)?;
    let version_input = version_input.trim();

    if version_input.is_empty() {
        Ok(Version::default(path))
    } else {
        let version_parts: Result<Vec<u32>, _> =
            version_input.split('.').map(|s| s.parse::<u32>()).collect();

        match version_parts {
            Ok(parts) if parts.len() == 3 => Ok(Version {
                major: parts[0],
                minor: parts[1],
                patch: parts[2],
                path: path.to_path_buf(),
            }),
            _ => {
                eprintln!("Invalid version format. Please use format like '1.2.3'");
                Ok(Version::default(path))
            }
        }
    }
}

fn get_version(matches: &ArgMatches) -> Version {
    let version_file_path = matches.get_one::<String>("version-file").unwrap();
    let version_path = match resolve_path(version_file_path) {
        Ok(path) => path,
        Err(err) => {
            eprintln!("Failed to resolve path: {}", err);
            std::process::exit(1);
        }
    };

    match Version::from_file(&version_path) {
        Ok(v) => v,
        Err(err) => match err {
            VersionError::IoError(ref io_err) if io_err.kind() == io::ErrorKind::NotFound => {
                println!(
                    "Version file not found at '{}'. Creating a new one",
                    version_path.display()
                );
                
                // Prompt first
                let version = match prompt_for_version(&version_path) {
                    Ok(v) => v,
                    Err(prompt_err) => {
                        eprintln!("Error during version prompt: {}", prompt_err);
                        std::process::exit(1);
                    }
                };
                
                // Then create directories and file
                if let Err(err) = ensure_directory_exists(&version_path) {
                    eprintln!("Failed to create directory: {}", err);
                    std::process::exit(1);
                }
                
                if let Err(write_err) = version.to_file() {
                    eprintln!("Failed to create version file: {}", write_err);
                    std::process::exit(1);
                }
                
                version
            }
            _ => {
                eprintln!("Error reading version file: {}", err);
                std::process::exit(1);
            }
        },
    }
}


fn show(version: &Version, just_number: bool) -> ! {
    if just_number {
        println!("{}.{}.{}", version.major, version.minor, version.patch);
    } else {
        println!(
            "'{}' version: {}.{}.{}",
            version.path.display(),
            version.major,
            version.minor,
            version.patch
        );
    }
    std::process::exit(0);
}

fn main() {
    let matches = Command::new("bump")
        .version(env!("CARGO_PKG_VERSION"))
        .about("Bump version numbers in a version file")
        .arg(
            Arg::new("version-file")
                .value_name("PATH")
                .value_parser(clap::value_parser!(String))
                .required(true)
                .help("Path to the version file"),
        )
        .arg(
            Arg::new("print")
                .long("print")
                .short('p')
                .action(clap::ArgAction::SetTrue)
                .help("Print the project version information"),
        )
        .arg(
            Arg::new("show")
                .long("show")
                .short('s')
                .action(clap::ArgAction::SetTrue)
                .help("Show the project version number, useful for CI/CD pipelines"),
        )
        .arg(
            Arg::new("major")
                .long("major")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(&["minor", "patch", "print"])
                .help("Bump the major version"),
        )
        .arg(
            Arg::new("minor")
                .long("minor")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(&["major", "patch", "print"])
                .help("Bump the minor version"),
        )
        .arg(
            Arg::new("patch")
                .long("patch")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(&["major", "minor", "print"])
                .help("Bump the patch version"),
        )
        .arg(
            Arg::new("output-file")
                .long("output-file")
                .value_name("FILE")
                .value_parser(clap::value_parser!(String))
                .default_missing_value("version.h")
                .num_args(0..=1)
                .help("Output the version to a C/C++ header file [default: version.h]"),
        )
        .get_matches();

    let mut version = get_version(&matches);

    if matches.get_flag("print") || matches.get_flag("show") {
        show(&version, matches.get_flag("show"));
    }

    let major = matches.get_flag("major");
    let minor = matches.get_flag("minor");
    let patch = matches.get_flag("patch");

    if version.bump(major, minor, patch) {
        if let Err(err) = version.to_file() {
            eprintln!("Failed to write version file: {}", err);
            std::process::exit(1);
        }

        let out_file = matches.get_one::<String>("output-file");
        if let Some(out_file) = out_file {
            if let Err(err) = fs::write(out_file, version.to_header()) {
                eprintln!("Failed to write header file: {}", err);
                std::process::exit(1);
            }
            println!("Header file written to {}", out_file);
        }

        println!(
            "Version bumped to {}.{}.{}",
            version.major, version.minor, version.patch
        );
    }
}
