use clap::{Arg, Command};
use std::{fs, path::Path, io, fmt};

#[cfg(test)]
mod tests;

// Keep the version in source code
const BUMP_VERSION: &str = "1.0.1";

#[derive(Debug)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
}

#[derive(Debug)]
enum VersionError {
    IoError(io::Error),
    ParseError(String),
}

impl fmt::Display for VersionError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            VersionError::IoError(err) => write!(f, "I/O error: {}", err),
            VersionError::ParseError(field) => write!(f, "Invalid {} value", field),
        }
    }
}

impl From<io::Error> for VersionError {
    fn from(err: io::Error) -> Self {
        VersionError::IoError(err)
    }
}

impl Version {
    fn default() -> Self {
        Version {
            major: 0,
            minor: 1,
            patch: 0,
        }
    }

    fn from_file(path: &Path) -> Result<Self, VersionError> {
        let content = fs::read_to_string(path)?;

        let mut major = 0;
        let mut minor = 0;
        let mut patch = 0;

        for line in content.lines() {
            if let Some(value) = line.strip_prefix("MAJOR=") {
                major = value.trim().parse().map_err(|_| VersionError::ParseError("MAJOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("MINOR=") {
                minor = value.trim().parse().map_err(|_| VersionError::ParseError("MINOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("PATCH=") {
                patch = value.trim().parse().map_err(|_| VersionError::ParseError("PATCH".to_string()))?;
            }
        }
        Ok(Version { major, minor, patch })
    }

    fn to_file(&self, path: &Path) -> Result<(), io::Error> {
        let content = format!(
r#"# This file is generated by:
#  ____  __  __  __  __  ____ 
# (  _ \(  )(  )(  \/  )(  _ \
#  ) _ < )(__)(  )    (  )___/
# (____/(______)(_/\/\_)(__)  
#
# https://github.com/launchfirestorm/bump

MAJOR={}
MINOR={}
PATCH={}
"#,
            self.major, self.minor, self.patch
        );
        fs::write(path, content)?;
        Ok(())
    }

    fn bump(&mut self, major: bool, minor: bool, patch: bool) {
        if major {
            self.major += 1;
            self.minor = 0;
            self.patch = 0;
        } else if minor {
            self.minor += 1;
            self.patch = 0;
        } else if patch {
            self.patch += 1;
        }
    }

    fn to_header(&self) -> String {
        format!(
r#"/** This file is generated by:
*  ____  __  __  __  __  ____ 
* (  _ \(  )(  )(  \/  )(  _ \
*  ) _ < )(__)(  )    (  )___/
* (____/(______)(_/\/\_)(__)  
*
* https://github.com/launchfirestorm/bump
*/

#define VERSION_MAJOR {}
#define VERSION_MINOR {}
#define VERSION_PATCH {}
"#,
            self.major, self.minor, self.patch
        )
    }
}

fn main() {
    let matches = Command::new("bump")
        .version(BUMP_VERSION)
        .arg(Arg::new("print")
            .long("print")
            .short('p')
            .action(clap::ArgAction::SetTrue)
            .help("Print the project version information"))
        .arg(Arg::new("major")
            .long("major")
            .action(clap::ArgAction::SetTrue)
            .conflicts_with_all(&["minor", "patch", "print"])
            .help("Bump the major version"))
        .arg(Arg::new("minor")
            .long("minor")
            .action(clap::ArgAction::SetTrue)
            .conflicts_with_all(&["major", "patch", "print"])
            .help("Bump the minor version"))
        .arg(Arg::new("patch")
            .long("patch")
            .action(clap::ArgAction::SetTrue)
            .conflicts_with_all(&["major", "minor", "print"])
            .help("Bump the patch version"))
        .arg(Arg::new("output-file")
            .long("output-file")
            .value_name("FILE")
            .value_parser(clap::value_parser!(String))
            .default_missing_value("version.h")
            .num_args(0..=1)
            .help("Output the version to a C/C++ header file [default: version.h]"))
        .get_matches();

    let print = matches.get_flag("print");
    if print {
        let version_path = Path::new("version");
        match Version::from_file(version_path) {
            Ok(v) => {
                println!("Found version: {}.{}.{}", v.major, v.minor, v.patch);
                std::process::exit(0);
            },
            Err(err) => {
                if let VersionError::IoError(ref io_err) = err {
                    if io_err.kind() == io::ErrorKind::NotFound {
                        println!("Version file not found. Default version is 0.1.0");
                        std::process::exit(0);
                    }
                }
                eprintln!("Error reading version file: {}", err);
                std::process::exit(1);
            }
        }
    }

    let major = matches.get_flag("major");
    let minor = matches.get_flag("minor");
    let patch = matches.get_flag("patch");

    if !major && !minor && !patch {
        eprintln!("Error: Must provide one of --major, --minor, or --patch");
        std::process::exit(1);
    }

    let version_path = Path::new("version");
    let mut version = match Version::from_file(version_path) {
        Ok(v) => v,
        Err(err) => {
            match err {
                VersionError::IoError(ref io_err) if io_err.kind() == io::ErrorKind::NotFound => {
                    println!("Version file not found. Creating a new one with default version 0.1.0");
                    Version::default()
                },
                _ => {
                    eprintln!("Error reading version file: {}", err);
                    std::process::exit(1);
                }
            }
        }
    };

    version.bump(major, minor, patch);
    
    if let Err(err) = version.to_file(version_path) {
        eprintln!("Failed to write version file: {}", err);
        std::process::exit(1);
    }

    let out_file = matches.get_one::<String>("output-file");
    if let Some(out_file) = out_file {
        if let Err(err) = fs::write(out_file, version.to_header()) {
            eprintln!("Failed to write header file: {}", err);
            std::process::exit(1);
        }
        println!("Header file written to {}", out_file);
    }

    println!("Version bumped to {}.{}.{}", version.major, version.minor, version.patch);
}
