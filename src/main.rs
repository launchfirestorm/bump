use clap::{Arg, ArgMatches, ArgGroup, Command};
use std::{
    fmt, fs, io,
    path::{Path, PathBuf},
    process::ExitCode,
};

#[cfg(test)]
mod tests;

#[derive(Debug)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
    candidate: u32,  // will be zero for point-release
    commit: String,  // will always be filled, regardless
    path: PathBuf,
}

#[derive(Debug)]
enum BumpError {
    IoError(io::Error),
    ParseError(String),
    LogicError(String),
}

enum PointType {
    Major,
    Minor,
    Patch,
}

enum BumpType {
    Point(PointType),
    Candidate, // candidate will bump the minor version and append a rc1
    Release,   // release will drop candidacy and not increment (hence released)
    Development,
    None,
}

impl fmt::Display for BumpError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BumpError::IoError(err) => write!(f, "I/O error: {err}"),
            BumpError::ParseError(field) => write!(f, "Invalid {field} value"),
            BumpError::LogicError(msg) => write!(f, "Error: {msg}"),
        }
    }
}

impl From<io::Error> for BumpError {
    fn from(err: io::Error) -> Self {
        BumpError::IoError(err)
    }
}

impl Version {
    fn default(path: &Path) -> Self {
        Version {
            major: 0,
            minor: 1,
            patch: 0,
            candidate: 0,
            commit: get_commit_sha().unwrap_or_else(|_| String::from("unknown")),
            path: path.to_path_buf(),
        }
    }

    fn from_file(path: &Path) -> Result<Self, BumpError> {
        let content = fs::read_to_string(path)?;

        let mut major = 0;
        let mut minor = 0;
        let mut patch = 0;
        let mut candidate = 0;
        let mut commit = String::new();

        for line in content.lines() {
            if let Some(value) = line.strip_prefix("MAJOR=") {
                major = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("MAJOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("MINOR=") {
                minor = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("MINOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("PATCH=") {
                patch = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("PATCH".to_string()))?;
            } else if let Some(value) = line.strip_prefix("CANDIDATE=") {
                candidate = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("CANDIDATE".to_string()))?;
            } else if let Some(value) = line.strip_prefix("COMMIT=") {
                commit = value.trim().to_string();
            }
        }
        Ok(Version {
            major,
            minor,
            patch,
            candidate,
            commit,
            path: path.to_path_buf(),
        })
    }

    fn to_file(&self) -> Result<(), BumpError> {
        let content = format!(
            r#"# This file is generated by:
#  ____  __  __  __  __  ____ 
# (  _ \(  )(  )(  \/  )(  _ \
#  ) _ < )(__)(  )    (  )___/
# (____/(______)(_/\/\_)(__)  
#
# https://github.com/launchfirestorm/bump

MAJOR={}
MINOR={}
PATCH={}
CANDIDATE={}
COMMIT={}
"#,
            self.major, self.minor, self.patch, self.candidate, self.commit
        );
        match fs::write(self.path.as_path(), content) {
            Ok(_) => Ok(()),
            Err(err) => Err(BumpError::IoError(err)),
        }
    }

    fn to_string(&self, bump_type: &BumpType) -> String {
        match bump_type {
            BumpType::Point(_) | BumpType::Release => format!("{}.{}.{}", self.major, self.minor, self.patch),
            BumpType::Candidate => format!("{}.{}.{}-rc{}", self.major, self.minor, self.patch, self.candidate),
            BumpType::Development => if self.candidate > 0 {
                format!("{}.{}.{}-rc{}+{}", self.major, self.minor, self.patch, self.candidate, self.commit)
            } else {
                format!("{}.{}.{}+{}", self.major, self.minor, self.patch, self.commit)
            },
            BumpType::None => {
                if self.commit.eq("tagged") {
                    if self.candidate > 0 {
                        format!("{}.{}.{}-rc{}", self.major, self.minor, self.patch, self.candidate)
                    } else {
                        format!("{}.{}.{}", self.major, self.minor, self.patch)
                    }
                } else {
                    format!("{}.{}.{}+{}", self.major, self.minor, self.patch, self.commit)
                }
            }
        }
    }

    fn bump(&mut self, bump_type: &BumpType) -> Result<(), BumpError> {
        match bump_type {
            BumpType::Point(PointType::Major) => {
                self.major += 1;
                self.minor = 0;
                self.patch = 0;
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Point(PointType::Minor) => {
                self.minor += 1;
                self.patch = 0;
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Point(PointType::Patch) => {
                self.patch += 1;
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Candidate => {
                if self.candidate > 0 {
                    self.candidate += 1;
                } else {
                    self.minor += 1;
                    self.candidate = 1; // start candidate at 1
                }
                self.patch = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Release => {
                // Release does not increment, just drops candidate and tags commit
                if self.candidate == 0 {
                    return Err(BumpError::LogicError("Cannot release without a candidate".to_string()));
                }
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Development => {
                self.commit = get_commit_sha()?;
            }
            BumpType::None => {
                () // no-op
            }
        }
        Ok(())
    }

    fn to_header(&self, bump_type: &BumpType, path: &Path) -> Result<(), BumpError> {
        let header = format!(
            r#"/** This file is generated by:
*  ____  __  __  __  __  ____ 
* (  _ \(  )(  )(  \/  )(  _ \
*  ) _ < )(__)(  )    (  )___/
* (____/(______)(_/\/\_)(__)  
*
* https://github.com/launchfirestorm/bump
*/

#define VERSION_MAJOR {}
#define VERSION_MINOR {}
#define VERSION_PATCH {}
#define VERSION_CANDIDATE {}
#define VERSION_COMMIT {}
#define VERSION_STRING "{}"
"#,
            self.major, self.minor, self.patch, self.candidate, self.commit, self.to_string(bump_type)
        );

        fs::write(path, header).map_err(BumpError::IoError)?;
        println!("Header file written to {}", path.display());
        Ok(())
    }
}

// meant to be run on tag pipelines
fn get_commit_sha() -> Result<String, BumpError> {
    let output = std::process::Command::new("git")
        .arg("rev-parse")
        .arg("--short=7")
        .arg("HEAD")
        .output()
        .map_err(BumpError::IoError)?;

    if output.status.success() {
        let commit = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(commit)
    } else {
        Err(BumpError::LogicError("Failed to get commit SHA".to_string()))
    }
}

fn resolve_path(input_path: &str) -> PathBuf {
    let path = Path::new(input_path);

    if path.is_absolute() {
        // Absolute path - return as is
        path.to_path_buf()
    } else {
        // Relative path - resolve relative to current directory
        std::env::current_dir()
            .unwrap_or_else(|_| PathBuf::from("."))
            .join(path)
    }
}

fn ensure_directory_exists(path: &Path) -> Result<(), BumpError> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent).map_err(BumpError::IoError)?;
        }
    }
    Ok(())
}

fn prompt_for_version(path: &Path) -> Result<Version, BumpError> {
    let mut version_input = String::new();
    println!("Enter the version number (e.g. 1.2.3) or press enter for default (0.1.0): ");

    io::stdin()
        .read_line(&mut version_input)
        .map_err(BumpError::IoError)?;
    let version_input = version_input.trim();

    if version_input.is_empty() {
        Ok(Version::default(path))
    } else {
        let version_parts: Result<Vec<u32>, _> =
            version_input.split('.').map(|s| s.parse::<u32>()).collect();

        match version_parts {
            Ok(parts) if parts.len() == 3 => Ok(Version {
                major: parts[0],
                minor: parts[1],
                patch: parts[2],
                candidate: 0,
                commit: get_commit_sha()?,
                path: path.to_path_buf(),
            }),
            _ => {
                Err(BumpError::ParseError("Invalid version format".to_string()))
            }
        }
    }
}

fn get_version(matches: &ArgMatches) -> Result<Version, BumpError> {
    let version_file_path = matches
        .get_one::<String>("bumpfile")
        .expect("bumpfile not found");
    let version_path = resolve_path(version_file_path);
    Version::from_file(&version_path)
}

fn get_bump_type(matches: &ArgMatches) -> Result<BumpType, BumpError> {
    if matches.get_flag("major") {
        Ok(BumpType::Point(PointType::Major))
    } else if matches.get_flag("minor") {
        Ok(BumpType::Point(PointType::Minor))
    } else if matches.get_flag("patch") {
        Ok(BumpType::Point(PointType::Patch))
    } else if matches.get_flag("candidate") {
        Ok(BumpType::Candidate)
    } else if matches.get_flag("release") {
        Ok(BumpType::Release)
    } else if matches.get_flag("development") {
        Ok(BumpType::Development)
    } else {
        Err(BumpError::LogicError(
            "No valid bump type specified".to_string(),
        ))
    }
}

fn initialize(bumpfile: &str) -> Result<Version, BumpError> {
    let filepath = resolve_path(bumpfile);
    ensure_directory_exists(&filepath)?;
    let version = prompt_for_version(&filepath)?;
    version.to_file()?;
    println!("Initialized new version file at '{}'", filepath.display());
    Ok(version)
}

fn print(version: &Version, matches: &ArgMatches) {
    let output: String;
    let no_newline = matches.get_flag("print-ci");
    let cmake = matches.get_flag("print-cmake");

    if cmake {
        print!("{}", version.to_string(&BumpType::Point(PointType::Patch)));
        return;
    } 

    if !version.commit.eq("tagged") {
        output = version.to_string(&BumpType::Development);
    } else if version.candidate > 0 {
        output = version.to_string(&BumpType::Candidate);
    } else {
        // PointType doesn't matter here
        output = version.to_string(&BumpType::Point(PointType::Patch));
    }

    if no_newline {
        print!("{output}");
    } else {
        println!("{output}");
    }
}


fn apply(matches: &ArgMatches) -> Result<(), BumpError> {
    let mut version = match get_version(matches) {
        Ok(v) => v,
        Err(err) => {
            if let BumpError::IoError(_) = err {
                let path = matches.get_one::<String>("bumpfile").unwrap();
                let resolved_path = resolve_path(path);
                // println!("If creating a new file, initialize with --init");
                return Err(BumpError::IoError(io::Error::new(
                    io::ErrorKind::NotFound,
                    format!("File not found: {}", resolved_path.display()),
                )));
            } else {
                return Err(err);
            }
        }
    };

    let bump_type = get_bump_type(matches)?;

    version.bump(&bump_type)?;

    match version.to_file() {
        Ok(()) => match bump_type {
                BumpType::Point(_) => println!("Bumped '{}' to point release {}", version.path.display(), version.to_string(&bump_type)),
                BumpType::Candidate => println!("Bumped '{}' to new candidate {}", version.path.display(), version.to_string(&bump_type)),
                BumpType::Release => println!("Bumped '{}' drop candidacy to release! {}", version.path.display(), version.to_string(&bump_type)),
                BumpType::Development => println!("Bumped '{}' to development build {}", version.path.display(), version.to_string(&bump_type)),
                BumpType::None => println!("no bump!, should not get here"),
        }
        Err(err) => {
            eprintln!("Failed to write version file: {err}");
            return Err(err);
        }
    }

    if matches.value_source("output-file").is_some() {
        let output_file = matches.get_one::<String>("output-file").unwrap();
        if let Err(err) = version.to_header(&BumpType::None, Path::new(&output_file)) {
            eprintln!("Failed to write header file: {err}");
            return Err(err);
        }
    }


    Ok(())
}

fn main() -> ExitCode {
    let matches = Command::new("bump")
        .version(env!("CARGO_PKG_VERSION"))
        .about("Semantic Version bumping with sane defaults")
        .arg(
            Arg::new("bumpfile")
                .value_name("PATH")
                .value_parser(clap::value_parser!(String))
                .default_value("bumpfile")
                .help("Path to the version file"),
        )
        .arg(
            Arg::new("init")
                .long("init")
                .action(clap::ArgAction::SetTrue)
                .help("initialize a new version file with default values")
        )
        .arg(
            Arg::new("print")
                .long("print")
                .action(clap::ArgAction::SetTrue)
                .group("print-group")
                .help("Print version from PATH"),
        )
        .arg(
            Arg::new("print-ci")
                .long("print-ci")
                .action(clap::ArgAction::SetTrue)
                .group("print-group")
                .help("Print version from PATH, without a newline"),
        )
        .arg(
            Arg::new("print-cmake")
                .long("print-cmake")
                .action(clap::ArgAction::SetTrue)
                .group("print-group")
                .help("Print version from PATH, cmake compatible format"),
        )
        .arg(
            Arg::new("major")
                .long("major")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(["minor", "patch", "print"])
                .help("Bump the major version"),
        )
        .arg(
            Arg::new("minor")
                .long("minor")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(["major", "patch", "print"])
                .help("Bump the minor version"),
        )
        .arg(
            Arg::new("patch")
                .long("patch")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(["major", "minor", "print"])
                .help("Bump the patch version"),
        )
        .arg(
            Arg::new("release")
                .long("release")
                .action(clap::ArgAction::SetTrue)
                .group("point-release")
                .conflicts_with_all(["major", "minor", "patch"])
                .help("Drop candidacy and promote to release")
        )
        .group(
            ArgGroup::new("point-release")
                .args(["major", "minor", "patch"])
                .conflicts_with_all(["candidate-release", "development-release", "print-group"])
        )
        .arg(
            Arg::new("candidate")
                .long("candidate")
                .action(clap::ArgAction::SetTrue)
                .help("if in candidacy increments the candidate version, otherwise bump the minor version and set the rc to 1")
                .group("candidate-release")
                .conflicts_with_all(["point-release", "development-release", "print-group"])
        )
        .arg(
            Arg::new("development")
                .long("dev")
                .action(clap::ArgAction::SetTrue)
                .help("Set the meta on semver")
                .group("development-release")
                .conflicts_with_all(["point-release", "candidate-release", "print-group"])
        )
        .arg(
            Arg::new("output-file")
                .long("output-file")
                .value_name("FILE")
                .value_parser(clap::value_parser!(String))
                .default_missing_value("version.h")
                .num_args(0..=1)
                .help("Output the version to a C/C++ header file [default: version.h]"),
        )
        .get_matches();

    if matches.get_flag("init") {
        let bumpfile = matches.get_one::<String>("bumpfile").unwrap();
        if let Err(err) = initialize(bumpfile) {
            eprintln!("Error initializing version file: {err}");
            return ExitCode::FAILURE;
        }
    } else if matches.contains_id("print-group") {
        let version = match get_version(&matches) {
            Ok(v) => v,
            Err(err) => {
                eprintln!("Error getting version: {err}");
                return ExitCode::FAILURE;
            }
        };
        print(&version, &matches);
    } else if matches.contains_id("point-release")
        || matches.contains_id("candidate-release")
        || matches.contains_id("development-release")
    {
        if let Err(err) = apply(&matches) {
            eprintln!("{err}");
            return ExitCode::FAILURE;
        }
    } else if matches.value_source("output-file").is_some() {
        // Handle output file generation
        let version = match get_version(&matches) {
            Ok(v) => v,
            Err(err) => {
                eprintln!("Error getting version: {err}");
                return ExitCode::FAILURE;
            }
        };
        let output_file = matches.get_one::<String>("output-file").unwrap();
        if let Err(err) = version.to_header(&BumpType::None, Path::new(output_file)) {
            eprintln!("Failed to write header file: {err}");
            return ExitCode::FAILURE;
        }
    } else {
        eprintln!( "No action specified. Run with --help to see available options." );
    }
    ExitCode::SUCCESS
}
