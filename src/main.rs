use clap::{Arg, ArgMatches, ArgGroup, Command};
use std::{
    fmt, fs, io,
    path::{Path, PathBuf},
    process::ExitCode,
};

#[cfg(test)]
mod tests;

#[derive(Debug)]
struct Version {
    major: u32,
    minor: u32,
    patch: u32,
    candidate: u32,  // will be zero for point-release
    commit: String,  // will always be filled, regardless
    path: PathBuf,
}

#[derive(Debug)]
enum BumpError {
    IoError(io::Error),
    ParseError(String),
    LogicError(String),
}

enum PointType {
    MAJOR,
    MINOR,
    PATCH,
}

enum BumpType {
    Point(PointType),
    Candidate,
    Development,
}

impl fmt::Display for BumpError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BumpError::IoError(err) => write!(f, "I/O error: {}", err),
            BumpError::ParseError(field) => write!(f, "Invalid {} value", field),
            BumpError::LogicError(msg) => write!(f, "Error: {}", msg),
        }
    }
}

impl From<io::Error> for BumpError {
    fn from(err: io::Error) -> Self {
        BumpError::IoError(err)
    }
}

impl Version {
    fn default(path: &Path) -> Self {
        Version {
            major: 0,
            minor: 1,
            patch: 0,
            candidate: 0,
            commit: String::new(),
            path: path.to_path_buf(),
        }
    }

    fn from_file(path: &Path) -> Result<Self, BumpError> {
        let content = fs::read_to_string(path)?;

        let mut major = 0;
        let mut minor = 0;
        let mut patch = 0;
        let mut candidate = 0;
        let mut commit = String::new();

        for line in content.lines() {
            if let Some(value) = line.strip_prefix("MAJOR=") {
                major = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("MAJOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("MINOR=") {
                minor = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("MINOR".to_string()))?;
            } else if let Some(value) = line.strip_prefix("PATCH=") {
                patch = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("PATCH".to_string()))?;
            } else if let Some(value) = line.strip_prefix("CANDIDATE=") {
                candidate = value
                    .trim()
                    .parse()
                    .map_err(|_| BumpError::ParseError("CANDIDATE".to_string()))?;
            } else if let Some(value) = line.strip_prefix("COMMIT=") {
                commit = value.trim().to_string();
            }
        }
        Ok(Version {
            major,
            minor,
            patch,
            candidate,
            commit,
            path: path.to_path_buf(),
        })
    }

    fn to_file(&self) -> Result<(), BumpError> {
        let content = format!(
            r#"# This file is generated by:
#  ____  __  __  __  __  ____ 
# (  _ \(  )(  )(  \/  )(  _ \
#  ) _ < )(__)(  )    (  )___/
# (____/(______)(_/\/\_)(__)  
#
# https://github.com/launchfirestorm/bump

MAJOR={}
MINOR={}
PATCH={}
CANDIDATE={}
COMMIT={}
"#,
            self.major, self.minor, self.patch, self.candidate, self.commit
        );
        match fs::write(self.path.as_path(), content) {
            Ok(_) => Ok(()),
            Err(err) => Err(BumpError::IoError(err)),
        }
    }

    fn to_string(&self, bump_type: &BumpType) -> String {
        match bump_type {
            BumpType::Point(_) => format!("{}.{}.{}", self.major, self.minor, self.patch),
            BumpType::Candidate => format!("{}.{}.{}-rc{}", self.major, self.minor, self.patch, self.candidate),
            BumpType::Development => if self.candidate > 0 {
                format!("{}.{}.{}-rc{}+{}", self.major, self.minor, self.patch, self.candidate, self.commit)
            } else {
                format!("{}.{}.{}+{}", self.major, self.minor, self.patch, self.commit)
            },
        }
    }

    fn bump(&mut self, bump_type: &BumpType) -> Result<(), BumpError> {
        match bump_type {
            BumpType::Point(PointType::MAJOR) => {
                self.major += 1;
                self.minor = 0;
                self.patch = 0;
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Point(PointType::MINOR) => {
                self.minor += 1;
                self.patch = 0;
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Point(PointType::PATCH) => {
                self.patch += 1;
                self.candidate = 0;
                self.commit = String::from("tagged");
            }
            BumpType::Candidate => {
                self.candidate += 1;
                self.commit = String::from("tagged");
            }
            BumpType::Development => {
                self.commit = get_commit_sha()?;
            }
        }
        Ok(())
    }

    fn to_header(&self, bump_type: &BumpType) -> String {
        format!(
            r#"/** This file is generated by:
*  ____  __  __  __  __  ____ 
* (  _ \(  )(  )(  \/  )(  _ \
*  ) _ < )(__)(  )    (  )___/
* (____/(______)(_/\/\_)(__)  
*
* https://github.com/launchfirestorm/bump
*/

#define VERSION_MAJOR {}
#define VERSION_MINOR {}
#define VERSION_PATCH {}
#define VERSION_CANDIDATE {}
#define VERSION_COMMIT {}
#define VERSION_STRING "{}"
"#,
            self.major, self.minor, self.patch, self.candidate, self.commit, self.to_string(bump_type)
        )
    }
}

// meant to be run on tag pipelines
fn get_commit_sha() -> Result<String, BumpError> {
    let output = std::process::Command::new("git")
        .arg("rev-parse")
        .arg("--short=7")
        .arg("HEAD")
        .output()
        .map_err(BumpError::IoError)?;

    if output.status.success() {
        let commit = String::from_utf8_lossy(&output.stdout).trim().to_string();
        Ok(commit)
    } else {
        Err(BumpError::LogicError("Failed to get commit SHA".to_string()))
    }
}

fn resolve_path(input_path: &str) -> PathBuf {
    let path = Path::new(input_path);

    let resolved_path = if path.is_absolute() {
        // Absolute path - return as is
        path.to_path_buf()
    } else {
        // Relative path - resolve relative to current directory
        std::env::current_dir()
            .unwrap_or_else(|_| PathBuf::from("."))
            .join(path)
    };

    resolved_path
}

fn ensure_directory_exists(path: &Path) -> Result<(), BumpError> {
    if let Some(parent) = path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent).map_err(BumpError::IoError)?;
        }
    }
    Ok(())
}

fn prompt_for_filepath() -> Result<PathBuf, BumpError> {
    let mut filename_input = String::new();
    println!("Enter the filename (e.g. version) or press enter for default (bumpfile): ");

    if let Err(e) = io::stdin().read_line(&mut filename_input) {
        return Err(BumpError::IoError(e));
    }

    let filename_input = filename_input.trim();

    if filename_input.is_empty() {
        Ok(PathBuf::from("bumpfile"))
    } else {
        Ok(PathBuf::from(filename_input))
    }
}

fn prompt_for_version(path: &Path) -> Result<Version, BumpError> {
    let mut version_input = String::new();
    println!("Enter the version number (e.g. 1.2.3) or press enter for default (0.1.0): ");

    io::stdin()
        .read_line(&mut version_input)
        .map_err(BumpError::IoError)?;
    let version_input = version_input.trim();

    if version_input.is_empty() {
        Ok(Version::default(path))
    } else {
        let version_parts: Result<Vec<u32>, _> =
            version_input.split('.').map(|s| s.parse::<u32>()).collect();

        match version_parts {
            Ok(parts) if parts.len() == 3 => Ok(Version {
                major: parts[0],
                minor: parts[1],
                patch: parts[2],
                candidate: 0,
                commit: get_commit_sha()?,
                path: path.to_path_buf(),
            }),
            _ => {
                eprintln!("Invalid version format. Please use format like '1.2.3'");
                Ok(Version::default(path))
            }
        }
    }
}

fn get_version(matches: &ArgMatches) -> Result<Version, BumpError> {
    let version_file_path = matches
        .get_one::<String>("bumpfile")
        .expect("bumpfile not found");
    let version_path = resolve_path(version_file_path);
    Version::from_file(&version_path)
}

fn get_bump_type(matches: &ArgMatches) -> Result<BumpType, BumpError> {
    if matches.get_flag("major") {
        Ok(BumpType::Point(PointType::MAJOR))
    } else if matches.get_flag("minor") {
        Ok(BumpType::Point(PointType::MINOR))
    } else if matches.get_flag("patch") {
        Ok(BumpType::Point(PointType::PATCH))
    } else if matches.get_flag("candidate") {
        Ok(BumpType::Candidate)
    } else if matches.get_flag("development") {
        Ok(BumpType::Development)
    } else {
        Err(BumpError::LogicError(
            "No valid bump type specified".to_string(),
        ))
    }
}

fn initialize() -> Result<Version, BumpError> {
    let filepath = prompt_for_filepath()?;
    ensure_directory_exists(&filepath)?;
    let version = prompt_for_version(&filepath)?;
    version.to_file()?;
    println!("Initialized new version file at '{}'", filepath.display());
    Ok(version)
}

fn show(version: &Version, full: bool) {
    let mut output = String::new();

    if full {
        output.push_str(&format!("'{}' version: ", version.path.display()));
    }

    if !version.commit.eq("tagged") {
        output.push_str(&version.to_string(&BumpType::Development));
    } else if version.candidate > 0 {
        output.push_str(&version.to_string(&BumpType::Candidate));
    } else {
        // PointType doesn't matter here
        output.push_str(&version.to_string(&BumpType::Point(PointType::PATCH)));
    }

    println!("{}", output);
}

fn write_output_file(matches: &ArgMatches, version: &Version) -> Result<(), BumpError> {
    if let Some(output_file) = matches.get_one::<String>("output-file") {
        fs::write(output_file, version.to_header(&BumpType::Point(PointType::PATCH)))
            .map_err(BumpError::IoError)?;
        println!("Header file written to {}", output_file);
    }
    Ok(())
}

fn apply(matches: &ArgMatches) -> Result<(), BumpError> {
    let mut version = match get_version(&matches) {
        Ok(v) => v,
        Err(err) => {
            if let BumpError::IoError(_) = err {
                let path = matches.get_one::<String>("bumpfile").unwrap();
                let resolved_path = resolve_path(path);
                // println!("If creating a new file, initialize with --init");
                return Err(BumpError::IoError(io::Error::new(
                    io::ErrorKind::NotFound,
                    format!("File not found: {}", resolved_path.display()),
                )));
            } else {
                return Err(err);
            }
        }
    };

    let bump_type = get_bump_type(&matches)?;

    version.bump(&bump_type)?;

    match version.to_file() {
        Ok(()) => println!( "Bumped '{}' to {}", version.path.display(), version.to_string(&bump_type)),
        Err(err) => {
            eprintln!("Failed to write version file: {}", err);
            return Err(err);
        }
    }

    if let Err(err) = write_output_file(&matches, &version) {
        eprintln!("Failed to write output file: {}", err);
        return Err(err);
    }
    Ok(())
}

fn main() -> ExitCode {
    let matches = Command::new("bump")
        .version(env!("CARGO_PKG_VERSION"))
        .about("Bump version numbers in a version file")
        .arg(
            Arg::new("bumpfile")
                .value_name("PATH")
                .value_parser(clap::value_parser!(String))
                .default_value("bumpfile")
                .help("Path to the version file"),
        )
        .arg(
            Arg::new("print")
                .long("print")
                .short('p')
                .action(clap::ArgAction::SetTrue)
                .help("Print the project version information"),
        )
        .arg(
            Arg::new("init")
                .long("init")
                .action(clap::ArgAction::SetTrue)
                .help("initialize a new version file with default values")
                .exclusive(true),
        )
        .arg(
            Arg::new("show")
                .long("show")
                .short('s')
                .action(clap::ArgAction::SetTrue)
                .help("Show the project version number, useful for CI/CD pipelines"),
        )
        .arg(
            Arg::new("major")
                .long("major")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(&["minor", "patch", "print"])
                .help("Bump the major version"),
        )
        .arg(
            Arg::new("minor")
                .long("minor")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(&["major", "patch", "print"])
                .help("Bump the minor version"),
        )
        .arg(
            Arg::new("patch")
                .long("patch")
                .action(clap::ArgAction::SetTrue)
                .conflicts_with_all(&["major", "minor", "print"])
                .help("Bump the patch version"),
        )
        .group(
            ArgGroup::new("point-release")
                .args(&["major", "minor", "patch"])
                .conflicts_with_all(&["candidate-release", "development-release"])
        )
        .arg(
            Arg::new("candidate")
                .long("candidate")
                .action(clap::ArgAction::SetTrue)
                .help("Set the candidate version (rc) number, starts from 1")
                .group("candidate-release")
                .conflicts_with_all(&["point-release", "development-release"])
        )
        .arg(
            Arg::new("development")
                .long("dev")
                .action(clap::ArgAction::SetTrue)
                .help("Set the meta on semver")
                .group("development-release")
                .conflicts_with_all(&["point-release", "candidate-release"])
        )
        .arg(
            Arg::new("output-file")
                .long("output-file")
                .value_name("FILE")
                .value_parser(clap::value_parser!(String))
                .default_missing_value("version.h")
                .num_args(0..=1)
                .help("Output the version to a C/C++ header file [default: version.h]"),
        )
        .get_matches();

    if matches.get_flag("init") {
        if let Err(err) = initialize() {
            eprintln!("Error initializing version file: {}", err);
            return ExitCode::FAILURE;
        }
    } else if matches.get_flag("show") || matches.get_flag("print") {
        let version = match get_version(&matches) {
            Ok(v) => v,
            Err(err) => {
                eprintln!("Error getting version: {}", err);
                return ExitCode::FAILURE;
            }
        };
        show(&version, matches.get_flag("print"));
        return ExitCode::SUCCESS;
    } else if matches.get_flag("major")
        || matches.get_flag("minor")
        || matches.get_flag("patch")
        || matches.get_flag("candidate")
        || matches.get_flag("development")
    {
        if let Err(err) = apply(&matches) {
            eprintln!("Error applying version bump: {}", err);
            return ExitCode::FAILURE;
        }
    } else {
        eprintln!(
            "No action specified. Use --init to initialize, --print to print version, or --major/--minor/--patch to bump the version."
        );
    }
    ExitCode::SUCCESS
}
